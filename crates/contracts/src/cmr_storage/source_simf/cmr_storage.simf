fn script_hash_for_input_script(state_data: u256) -> u256 {
    // This is the bulk of our "compute state commitment" logic from above.
    let tap_leaf: u256 = jet::tapleaf_hash();
    let state_ctx1: Ctx8 = jet::tapdata_init();
    let state_ctx2: Ctx8 = jet::sha_256_ctx_8_add_32(state_ctx1, state_data);
    let state_leaf: u256 = jet::sha_256_ctx_8_finalize(state_ctx2);
    let tap_node: u256 = jet::build_tapbranch(tap_leaf, state_leaf);

    // Compute a taptweak using this.
    let bip0341_key: u256 = 0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0;
    let tweaked_key: u256 = jet::build_taptweak(bip0341_key, tap_node);
    
    // Turn the taptweak into a script hash
    let hash_ctx1: Ctx8 = jet::sha_256_ctx_8_init();
    let hash_ctx2: Ctx8 = jet::sha_256_ctx_8_add_2(hash_ctx1, 0x5120); // Segwit v1, length 32
    let hash_ctx3: Ctx8 = jet::sha_256_ctx_8_add_32(hash_ctx2, tweaked_key);
    jet::sha_256_ctx_8_finalize(hash_ctx3)
}

fn main() {
    let state_data: u256 = witness::STATE;
    let (state1, state2, state3, state4): (u64, u64, u64, u64) = <u256>::into(state_data);
    
    // Assert that the input is correct, i.e. "load".
    assert!(jet::eq_256(
        script_hash_for_input_script(state_data),
        unwrap(jet::input_script_hash(jet::current_index()))
    ));

    // Do a state update (and fail on 64-bit overflow even though we've got 192 other
    // bits we could be using..)
    let (carry, new_state4): (bool, u64) = jet::add_64(state4, 1);
    assert!(jet::eq_1(<bool>::into(carry), 0));
    
    let new_state: u256 = <(u64, u64, u64, u64)>::into((state1, state2, state3, new_state4));
    // Assert that the output is correct, i.e. "store".
    assert!(jet::eq_256(
        script_hash_for_input_script(new_state),
        unwrap(jet::output_script_hash(jet::current_index()))
    ));
}